 Downstream Collectors
The groupingBy method yields a map whose values are lists. If you want to process those lists in some way, supply a downstream collector. For example, if you want sets instead of lists, you can use the Collectors.toSet collector that you saw in the preceding section:

Map<String, Set<Locale>> countryToLocaleSet = Locale.availableLocales().collect(
   groupingBy(Locale::getCountry, toSet()));
In this example, as well as the remaining examples of this section, I assume a static import of java.util.stream.Collectors.* to make the expressions easier to read.

You can also apply groupingBy twice:

Map<String, Map<String, List<Locale>>> countryAndLanguageToLocale =
   Locale.availableLocales().collect(
      groupingBy(Locale::getCountry,
         groupingBy(Locale::getLanguage)));
Then countryAndLanguageToLocale.get("IN").get("hi") is a list of the Hindi locales in India. (There are several variants.)

Several collectors are provided for reducing collected elements to numbers:

counting produces a count of the collected elements. For example,

Map<String, Long> countryToLocaleCounts = Locale.availableLocales().collect(
   groupingBy(Locale::getCountry, counting()));
counts how many locales there are for each country.

summing(Int|Long|Double) and averaging(Int|Long|Double) apply a provided function to the downstream elements and produce the sum or average of the function's results. For example,

public record City(String name, String state, int population) {}
. . .
Map<String, Integer> stateToCityPopulation = cities.collect(
   groupingBy(City::state, averagingInt(City::population)));
computes the average of populations per state in a stream of cities.

maxBy and minBy take a comparator and produce maximum and minimum of the downstream elements. For example,

Map<String, Optional<City>> stateToLargestCity = cities.collect(
   groupingBy(City::state,
      maxBy(Comparator.comparing(City::population))));
produces the largest city per state.

The collectingAndThen collector adds a final processing step behind a collector. For example, if you want to know how many distinct results there are, collect them into a set and then compute the size:

Map<Character, Integer> stringCountsByStartingLetter = strings.collect(
   groupingBy(s -> s.charAt(0),
      collectingAndThen(toSet(), Set::size)));
The mapping collector does the opposite. It applies a function to each collected element and passes the results to a downstream collector.

Map<Character, Set<Integer>> stringLengthsByStartingLetter = strings.collect(
   groupingBy(s -> s.charAt(0),
      mapping(String::length, toSet())));
Here, we group strings by their first character. Within each group, we produce the lengths and collect them in a set.

The mapping method also yields a nicer solution to a problem from the preceding section—gathering a set of all languages in a country.

Map<String, Set<String>> countryToLanguages = Locale.availableLocales().collect(
   groupingBy(Locale::getDisplayCountry,
      mapping(Locale::getDisplayLanguage,
         toSet())));
There is a flatMapping method as well, for use with functions that return streams.

If the grouping or mapping function has return type int, long, or double, you can collect elements into a summary statistics object, as discussed in Section 1.8. For example,

Map<String, IntSummaryStatistics> stateToCityPopulationSummary = cities.collect(
   groupingBy(City::state,
      summarizingInt(City::population)));
Then you can get the sum, count, average, minimum, and maximum of the function values from the summary statistics objects of each group.

The filtering collector applies a filter to each group, for example:

Map<String, Set<City>> largeCitiesByState
   = cities.collect(
      groupingBy(City::state,
         filtering(c -> c.population() > 500000,
            toSet()))); // States without large cities have empty sets
Finally, you can use the teeing collector to branch into two downstream collections. This is useful whenever you need to compute more than one result from a stream. Suppose you want to collect city names and also compute their average population. You can't read a stream twice, but teeing lets you carry out two computations. Specify two downstream collectors and a function that combines the results.

record Pair<S, T>(S first, T second) {}
Pair<List<String>, Double> result = cities.filter(c -> c.state().equals("NV"))
   .collect(teeing(
      mapping(City::name, toList()), // First downstream collector
      averagingDouble(City::population), // Second downstream collector
      (list, avg) -> new Pair(list,  avg))); // Combining function
There are also three versions of a reducing method that apply general reductions, as described in the next section.

Composing collectors is powerful, but it can lead to very convoluted expressions. The best use is with groupingBy or partitioningBy to process the “downstream” map values. Otherwise, simply apply methods such as map, reduce, count, max, or min directly on streams.

The example program in Listing 1.6 demonstrates downstream collectors.

Listing 1.6 collecting/DownstreamCollectors.java
package collecting;

import static java.util.stream.Collectors.*;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.stream.*;

/**
 * @version 1.02 2023-10-19
 * @author Cay Horstmann
 */
public class DownstreamCollectors
{
   public record City(String name, String state, int population) {}

   public static Stream<City> readCities(String filename) throws IOException
   {
      return Files.lines(Path.of(filename))
         .map(l -> l.split(", "))
         .map(a -> new City(a[0], a[1], Integer.parseInt(a[2])));
   }

   public static void main(String[] args) throws IOException
   {
      Map<String, Set<Locale>> countryToLocaleSet 
         = Locale.availableLocales().collect(
            groupingBy(Locale::getCountry, toSet()));
      System.out.println("countryToLocaleSet: " + countryToLocaleSet);

      Map<String, Map<String, List<Locale>>> countryAndLanguageToLocale 
         = Locale.availableLocales().collect(
            groupingBy(Locale::getCountry,
               groupingBy(Locale::getLanguage)));
      System.out.println("Hindi locales in India: "
         + countryAndLanguageToLocale.get("IN").get("hi"));

      Map<String, Long> countryToLocaleCounts 
         = Locale.availableLocales().collect(
            groupingBy(Locale::getCountry, counting()));
      System.out.println("countryToLocaleCounts: " + countryToLocaleCounts);

      Stream<City> cities = readCities("cities.txt");
      Map<String, Integer> stateToCityPopulation 
         = cities.collect(
            groupingBy(City::state, summingInt(City::population)));
      System.out.println("stateToCityPopulation: " + stateToCityPopulation);

      cities = readCities("cities.txt");
      Map<String, Optional<String>> stateToLongestCityName = cities
         .collect(groupingBy(City::state,
            mapping(City::name, maxBy(Comparator.comparing(String::length)))));
      System.out.println("stateToLongestCityName: " + stateToLongestCityName);

      Map<String, Set<String>> countryToLanguages 
         = Locale.availableLocales().collect(
            groupingBy(Locale::getDisplayCountry, 
               mapping(Locale::getDisplayLanguage, toSet())));
      System.out.println("countryToLanguages: " + countryToLanguages);

      cities = readCities("cities.txt");
      Map<String, IntSummaryStatistics> stateToCityPopulationSummary = cities
         .collect(groupingBy(City::state, summarizingInt(City::population)));
      System.out.println(stateToCityPopulationSummary.get("NY"));

      cities = readCities("cities.txt");
      Map<String, String> stateToCityNames = cities.collect(
         groupingBy(City::state,
            reducing("", City::name, (s, t) -> s.length() == 0 ? t : s + ", " + t)));

      cities = readCities("cities.txt");
      stateToCityNames = cities.collect(groupingBy(City::state,
         mapping(City::name, joining(", "))));
      System.out.println("stateToCityNames: " + stateToCityNames);

      cities = readCities("cities.txt");
      record Pair<S, T>(S first, T second) {}
      Pair<List<String>, Double> result = cities.filter(c -> c.state().equals("NV"))
         .collect(teeing(
            mapping(City::name, toList()),
            averagingDouble(City::population),
            (names, avg) -> new Pair<>(names, avg)));
      System.out.println(result);
   }
}
java.util.stream.Collectors 8

public static <T,K,A,D> Collector<T,?,Map<K,D>> groupingBy(Function<? super T,? extends K> classifier, Collector<? super T,A,D> downstream)

yields a collector that produces a map. The keys are the results of applying classifier to all collected elements. The values are the results of collecting elements with the same key, using the downstream collector.

static <T> Collector<T,?,Long> counting()

yields a collector that counts the collected elements.

static <T> Collector<T,?,Integer> summingInt(ToIntFunction<? super T> mapper)

static <T> Collector<T,?,Long> summingLong(ToLongFunction<? super T> mapper)

static <T> Collector<T,?,Double> summingDouble(ToDoubleFunction<? super T> mapper)

yield a collector that computes the sum of the results of applying mapper to the collected elements.

static <T> Collector<T,?,Optional<T>> maxBy(Comparator<? super T> comparator)

static <T> Collector<T,?,Optional<T>> minBy(Comparator<? super T> comparator)

yield a collector that computes the maximum or minimum of the collected elements, using the ordering specified by comparator.

static <T,A,R,RR> Collector<T,A,RR> collectingAndThen(Collector<T,A,R> downstream, Function<R,RR> finisher)

yields a collector that sends elements to the downstream collector and then applies the finisher function to its result.

static <T,U,A,R> Collector<T,?,R> mapping(Function<? super T,? extends U> mapper, Collector<? super U,A,R> downstream)

yields a collector that calls mapper on each element and passes the results to the downstream collector.

static <T,U,A,R> Collector<T,?,R> flatMapping(Function<? super T,? extends Stream<? extends U>> mapper, Collector<? super U,A,R> downstream)

yields a collector that calls mapper on each element and passes the elements of the results to the downstream collector.

static <T,A,R> Collector<T,?,R> filtering(Predicate<? super T> predicate, Collector<? super T,A,R> downstream)

yields a collector that passes the elements fulfilling the predicate to the downstream collector.

