# filter, map, and flatMap

Streams let you transform data easily. Transformation means creating a new stream whose elements are based on another stream.

## filter â€” Keep only what you want

The `filter` method keeps elements that match a condition.
The condition is a `Predicate<T>`, which is a function returning `true` or `false`.

```java
List<String> words = List.of("apple", "banana", "strawberry", "kiwi");

// Keep only long words (length > 5)
Stream<String> longWords = words.stream()
    .filter(w -> w.length() > 5);

longWords.forEach(System.out::println);
```

## map â€” Transform each element

Use `map` when you want to change each element in a stream.
The function you provide returns a new value for each element.

```java
List<String> words = List.of("Apple", "Banana", "Cherry");

// Convert all words to lowercase
Stream<String> lowercaseWords = words.stream()
    .map(String::toLowerCase);

lowercaseWords.forEach(System.out::println);
```

Here, we used `map` with a method reference. You can also use a lambda to pick part of a string:

```java
Stream<Character> firstLetters = words.stream()
    .map(w -> w.charAt(0));

firstLetters.forEach(System.out::println);
```


Often, you want to transform the values in a stream in some way. Use the map method and pass the function that carries out the transformation. For example, you can transform all words to lowercase like this:

Stream<String> lowercaseWords = words.stream().map(String::toLowerCase);


Stream<Character> firstCodeUnits = words.stream().map(s -> s.charAt(0));
The resulting stream contains the first code unit of each word.


When you use map, a function is applied to each element, yielding a new stream of the returned values. Now consider the situation where the returned values are themselves streams. An example is a method graphemeClusters that yields all grapheme clusters of a string. For example, graphemeClusters("Ciao ðŸ‡®ðŸ‡¹") is a stream of strings "C", "i", "a", "o", " ", "ðŸ‡®ðŸ‡¹". (Note that the flag consists of four char values, so the graphemeClusters method has to do some heavy lifting to make this happen. We will look at the implementation momentarily.)

Now let's map the graphemeClusters method on a stream of strings:

List<String> words = List.of(..., "your", "boat", ...);
Stream<Stream<String>> result = words.stream().map(w -> graphemeClusters(w));
You will get a stream of streams, like [. . . ["y", "o", "u", "r"], ["b", "o", "a", "t"], . . .]. To flatten it out to a single stream [. . . "y", "o", "u", "r", "b", "o", "a", "t", . . .], use the flatMap method instead of map:

Stream<String> flatResult = words.stream().flatMap(w -> graphemeClusters(w));
   // Calls graphemeClusters on each word and flattens the results
Now that you have seen how to use the graphemeClusters method, how do you write it? One way is to use a regular expression that breaks along grapheme cluster boundaries:

public static Stream<String> graphemeClusters(String s)
{
   return new Scanner(s).useDelimiter("\\b{g}").tokens();
}
Here we were lucky that it was easy to write a method that produces a new stream for every stream element. Sometimes that is not so easy. It can also be a little inefficient to create so many streams. The mapMulti method offers an alternative. Instead of producing a stream of results, you generate the results and pass them to a collectorâ€”an object of a class implementing the functional interface Consumer. For each result, invoke the collector's accept method.

Let's do this with an example. The following loop produces the grapheme clusters of a string s:

BreakIterator iter = BreakIterator.getCharacterInstance();
. . .
iter.setText(s);
int start = iter.first();
int end = iter.next();
while (end != BreakIterator.DONE) {
   String gc = s.substring(start, end);
   start = end;
   end = iter.next();
   // Do something with gc
}
When calling mapMulti, you provide a function that is invoked with the stream element and the collector. In your function, pass your results to the collector.

Stream<String> result = words.stream().mapMulti((s, collector) ->
   {
      iter.setText(s);
      int start = iter.first();
      int end = iter.next();
      while (end != BreakIterator.DONE)
      {
         String gc = s.substring(start, end);
         start = end;
         end = iter.next();
         collector.accept(gc);
      }
   });