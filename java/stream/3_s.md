# The filter, map, and flatMap Methods

A stream transformation produces a stream whose elements are derived from those of another stream. You have already seen the filter transformation that yields a new stream with those elements that match a certain condition. Here, we transform a stream of strings into another stream containing only long words:

```java
List<String> words = . . .;
Stream<String> longWords = words.stream().filter(w -> w.length() > 12)
```
The parameter type of filter is Predicate<T>â€”that is, a function from T to boolean.

Often, you want to transform the values in a stream in some way. Use the map method and pass the function that carries out the transformation. For example, you can transform all words to lowercase like this:

Stream<String> lowercaseWords = words.stream().map(String::toLowerCase);
Here, we used map with a method reference. Often, you will use a lambda expression instead:

Stream<Character> firstCodeUnits = words.stream().map(s -> s.charAt(0));
The resulting stream contains the first code unit of each word.


When you use map, a function is applied to each element, yielding a new stream of the returned values. Now consider the situation where the returned values are themselves streams. An example is a method graphemeClusters that yields all grapheme clusters of a string. For example, graphemeClusters("Ciao ðŸ‡®ðŸ‡¹") is a stream of strings "C", "i", "a", "o", " ", "ðŸ‡®ðŸ‡¹". (Note that the flag consists of four char values, so the graphemeClusters method has to do some heavy lifting to make this happen. We will look at the implementation momentarily.)

Now let's map the graphemeClusters method on a stream of strings:

List<String> words = List.of(..., "your", "boat", ...);
Stream<Stream<String>> result = words.stream().map(w -> graphemeClusters(w));
You will get a stream of streams, like [. . . ["y", "o", "u", "r"], ["b", "o", "a", "t"], . . .]. To flatten it out to a single stream [. . . "y", "o", "u", "r", "b", "o", "a", "t", . . .], use the flatMap method instead of map:

Stream<String> flatResult = words.stream().flatMap(w -> graphemeClusters(w));
   // Calls graphemeClusters on each word and flattens the results
Now that you have seen how to use the graphemeClusters method, how do you write it? One way is to use a regular expression that breaks along grapheme cluster boundaries:

public static Stream<String> graphemeClusters(String s)
{
   return new Scanner(s).useDelimiter("\\b{g}").tokens();
}
Here we were lucky that it was easy to write a method that produces a new stream for every stream element. Sometimes that is not so easy. It can also be a little inefficient to create so many streams. The mapMulti method offers an alternative. Instead of producing a stream of results, you generate the results and pass them to a collectorâ€”an object of a class implementing the functional interface Consumer. For each result, invoke the collector's accept method.

Let's do this with an example. The following loop produces the grapheme clusters of a string s:

BreakIterator iter = BreakIterator.getCharacterInstance();
. . .
iter.setText(s);
int start = iter.first();
int end = iter.next();
while (end != BreakIterator.DONE) {
   String gc = s.substring(start, end);
   start = end;
   end = iter.next();
   // Do something with gc
}
When calling mapMulti, you provide a function that is invoked with the stream element and the collector. In your function, pass your results to the collector.

Stream<String> result = words.stream().mapMulti((s, collector) ->
   {
      iter.setText(s);
      int start = iter.first();
      int end = iter.next();
      while (end != BreakIterator.DONE)
      {
         String gc = s.substring(start, end);
         start = end;
         end = iter.next();
         collector.accept(gc);
      }
   });